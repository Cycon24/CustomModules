# -*- coding: utf-8 -*-
"""
Created on Sun Oct 19 20:25:15 2025

@author: Cycon Gaming Night

generated by ChatGPT
"""
# file: utils/table_writer.py
from __future__ import annotations
from typing import Dict, List, Iterable, Mapping, Optional, Any, Literal
import math
import os
import tempfile
from pathlib import Path

def write_dict_table(
    data: Mapping[str, List[Any]],
    file_path: str | os.PathLike,
    column_order: Optional[Iterable[str]] = None,
    formats: Optional[Mapping[str, str]] = None,
    default_float_format: str = ".4f",
    spacing: int = 4,
    *,
    units: Optional[Mapping[str, str]] = None,
    units_style: Literal["brackets", "plain"] = "brackets",
) -> None:
    """
    Write a dict-of-lists to a text file as a fixed-width table.

    - Omits any column where *all* values are `None` (after length validation).
    - Keeps zero-row tables intact (no omission due to emptiness).
    - Atomic write to avoid partial files.

    Args:
        data: dict where each key is a column name and value is a list of cells.
        file_path: destination path.
        column_order: explicit column order. Defaults to data's key order.
        formats: optional column -> Python format spec (e.g., '.3f', 'g').
        default_float_format: used when formats is not provided.
        spacing: spaces between columns.
        units: optional column -> unit string; shows a units row under header.
        units_style: 'brackets' wraps units as [unit]; 'plain' uses raw string.

    Raises:
        ValueError: on empty data, inconsistent lengths, unknown columns,
                    or if all columns would be omitted.
    """
    if not data:
        raise ValueError("`data` is empty.")

    # Resolve column order and validate keys exist
    cols = list(column_order) if column_order else list(data.keys())
    missing = [c for c in cols if c not in data]
    if missing:
        raise ValueError(f"Unknown columns in column_order: {missing}")

    # Validate equal lengths
    lengths = {c: len(data[c]) for c in cols}
    unique_lengths = set(lengths.values())
    if len(unique_lengths) != 1:
        raise ValueError(f"Inconsistent column lengths: {lengths}")
    n_rows = unique_lengths.pop()

    # Omit columns that are entirely None (only when there are rows)
    if n_rows > 0:
        to_drop = {c for c in cols if all(v is None for v in data[c])}
        cols = [c for c in cols if c not in to_drop]
        if not cols:
            raise ValueError("All columns were omitted because all values are None.")

    def is_number(x: Any) -> bool:
        try:
            float(x)
            return not (isinstance(x, float) and (math.isnan(x) or math.isinf(x)))
        except Exception:
            return False

    def make_formatter(col: str):
        # Explicit format spec takes priority
        if formats and col in formats:
            spec = formats[col]
            def f(v: Any) -> str:
                if v is None:
                    return ""
                try:
                    return format(float(v), spec) if is_number(v) else f"{v}"
                except Exception:
                    return f"{v}"
            return f

        # Infer numeric vs non-numeric
        sample_vals = data[col]
        is_numeric_col = any(is_number(v) for v in sample_vals if v is not None)
        if is_numeric_col:
            spec = default_float_format
            def f(v: Any) -> str:
                if v is None:
                    return ""
                try:
                    return format(float(v), spec)
                except Exception:
                    return f"{v}"
            return f

        # Fallback: plain string
        return lambda v: "" if v is None else f"{v}"

    # Build formatters and preformat cells
    formatters = {c: make_formatter(c) for c in cols}
    formatted_cells: Dict[str, List[str]] = {
        c: [formatters[c](v) for v in data[c]] for c in cols
    }

    # Determine alignment: right for numeric-like columns, else left
    def is_numeric_col(col: str) -> bool:
        return any(is_number(v) for v in data[col] if v is not None)

    align_right = {c: is_numeric_col(c) for c in cols}

    # Units row preparation (ignored for omitted columns)
    units = units or {}
    def unit_str_for(col: str) -> str:
        u = units.get(col, "") or ""
        if not u:
            return ""
        return f"[{u}]" if units_style == "brackets" else u

    units_row = {c: unit_str_for(c) for c in cols}
    any_units = any(bool(units_row[c]) for c in cols)

    # Compute widths incl. header names, units, and data cells
    header_widths = {c: len(str(c)) for c in cols}
    unit_widths = {c: len(units_row[c]) for c in cols}
    cell_widths = {c: max((len(s) for s in formatted_cells[c]), default=0) for c in cols}
    col_widths = {c: max(header_widths[c], unit_widths[c], cell_widths[c]) for c in cols}

    sep = " " * spacing

    def pad(s: str, width: int, right: bool) -> str:
        return s.rjust(width) if right else s.ljust(width)

    header = sep.join(pad(str(c), col_widths[c], align_right[c]) for c in cols)
    dash_line = "-" * len(header)
    units_line = sep.join(pad(units_row[c], col_widths[c], align_right[c]) for c in cols) if any_units else None

    rows = [
        sep.join(pad(formatted_cells[c][r], col_widths[c], align_right[c]) for c in cols)
        for r in range(n_rows)
    ]

    # Atomic write
    dst = Path(file_path)
    dst.parent.mkdir(parents=True, exist_ok=True)
    with tempfile.NamedTemporaryFile("w", delete=False, encoding="utf-8", dir=dst.parent) as tmp:
        tmp.write(dash_line + "\n")
        tmp.write(header + "\n")
        if units_line is not None:
            tmp.write(units_line + "\n")
        tmp.write(dash_line + "\n")
        for line in rows:
            tmp.write(line + "\n")
        tmp_path = tmp.name
    os.replace(tmp_path, dst)

if __name__ == "__main__":
    # Example showcasing omission: 'TPR' is all None -> will be dropped.
    sample = {
        "Tt4":    [1800, 2000, 2200, 2400],
        "F_mdot": [713.27, 826.06, 930.51, 1028.23],
        "S":      [0.10427, 0.11048, 0.11623, 0.12161],
        "f_tot":  [0.02066, 0.02535, 0.03004, 0.03473],
        "eta_T":  [0.7639, 0.7639, 0.7639, 0.7639],
        "eta_P":  [0.6234, 0.5884, 0.5593, 0.5345],
        "eta_O":  [0.4763, 0.4495, 0.4273, 0.4084],
        "TPR":    [None, None, None, None],  # will be omitted
        "Me":     [3.1560, 3.2531, 3.3304, 3.3935],
        "Ve":     [1303.69, 1416.47, 1520.92, 1618.64],
    }
    order = ["Tt4","F_mdot","S","f_tot","eta_T","eta_P","eta_O","TPR","Me","Ve"]
    fmts = {
        "Tt4": ".0f", "F_mdot": ".2f", "S": ".5f", "f_tot": ".5f",
        "eta_T": ".4f", "eta_P": ".4f", "eta_O": ".4f",
        "Me": ".4f", "Ve": ".2f",
    }
    units_map = {
        "Tt4": "K",
        "F_mdot": "N·s/kg",
        "S": "kg/N·s",
        "f_tot": "-",
        "eta_T": "-",
        "eta_P": "-",
        "eta_O": "-",
        "TPR": "-",  # won't show since column is omitted
        "Me": "-",
        "Ve": "m/s",
    }

    write_dict_table(
        sample,
        file_path="out/table_with_units_and_omit.txt",
        column_order=order,   # 'TPR' in order but will be dropped safely
        formats=fmts,
        spacing=4,
        units=units_map,
        units_style="brackets",
    )
    print("Wrote out/table_with_units_and_omit.txt")
